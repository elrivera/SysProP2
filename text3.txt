#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>  
#include <dirent.h>
#include "arraylist.h"
#include "tok.h"
 
list_t parse(int fd);
void getDir();
void changeDir(char* dest);
char* checkFile(char* command);
void asterisk(char* tok, list_t* param);
list_t parseb(int fd);

void getDir(){
    char cwd[1024]; // buffer size
    //printf("here\n");
    getcwd(cwd, sizeof(cwd));
    strcat(cwd, "\n");
    write (STDOUT_FILENO, cwd, strlen(cwd));
    // int chdir(char *pathname), returns 0 if successful;
    // char *getcwd(char *buf, size_t size);
}

void changeDir(char* dest){

    if (dest == NULL){

        char* to = getenv("HOME");

        if (chdir(to) != 0){
            perror("cd failed");
        }
        return;
    }

    char cwd[1024];
    getcwd(cwd, sizeof(cwd));
    char* dir = strcat(cwd, "/");
    char* to = strcat(dir, dest);
    if (chdir(to) != 0){
        perror("cd failed");
    }
}

int main(int argc, char **argv){
    char buf[100];
    char *msgg="mysh> ";
    char *msg="parameters:\n";
    char *mmsg="command: ";
    char *omsg="goodbye!\n";
    char *exit = "exit";
    char *nl = "\n";
    char * s = " ";
    char *init =  "Welcome to MyShell!\n";
    char *pwd = "pwd";
    char *oop = "!";
    char *cd = "cd";
    char *piperr = "cannot pipe twice in one command\n";
    char *inerr = "cannot redirect input multiple times in the same command\n";
    char *outerr = "cannot redirect output multiple times in the same command\n";
    char *tmerr = "cannot pipe and redirect io in the same command\n";
    char *filefail = "could not find file\n";
    char *dupfail = "couldn't dup\n";
    char *execfail = "could not execute command\n";
    char *comfail = "could not find command\n";
    char *pipefail = "pipe failed";
    char *forkfail = "fork failed";
    
    int opened = 0;
    int err = 0;
    int p = 0;
    if(argc > 2) {
        printf("too many arguments. failed\n");
        return 1;
    }

    write (STDOUT_FILENO, init, strlen(init));
    int rep = 0;

    
    //batch mode
    // if(argc > 1){

    //     char cmd[100];
    //     char *envp[] = {(char *) "PATH=/bin", 0 };

    //     int z = 0;
    //     int l = al_length(&commands);
    //     char* command = al_lookup(&commands, 0);
    //     char* in = NULL;
    //     char* out = NULL;
    //     int indicator = 0;

    //     return;
    // }
    list_t comms;
    int x = 0;
    if(argc == 2){
        //printf("again\n");
        if(opened == 0){
            int file = open(argv[1], O_RDONLY);
            if (file == -1){
                printf("could not open file");
                return 1;
            }
                
            //printf("opened\n");
        
            if (dup2(file, STDIN_FILENO) == -1){
                printf("could not change input");
                return 2;
            }
            opened++;
            //printf("dup\n");
        }
        comms = parseb(STDIN_FILENO);
        al_push(&comms, NULL);
        /*
        char* y = al_lookup(&comms, 0);
        printf("%s", y);
        int i = 0;

        int j = size(&comms);
        printf("%d\n", j);
        if (j == 0) return 1;
        //int z;
        while(y != NULL){
            write (STDOUT_FILENO, y, strlen(y));
            i++;
            y = al_lookup(&comms, i);
            //p = strtok()
            //printf("%d ", i);
            
            write (STDOUT_FILENO, nl, strlen(nl));
        }
        printf("done\n");
        */
    }

    
        //return 1;

    //interactive Mode
    while (1) {
        if (err != 0) break;

        //write mysh prompt
        write (STDOUT_FILENO, msgg, strlen(msgg));

        /*
        int n;
        n=read (STDIN_FILENO, buf, sizeof(buf));
        write (STDOUT_FILENO, msg, strlen(msg));
        
        write (STDOUT_FILENO, buf, n);
        */
        
        //create arraylist of commands
        if (opened == 1) if(al_lookup(&comms, x) == NULL) break;
        
        list_t commands;
        if (opened == 1){
            if(al_lookup(&comms, x) == NULL) break;
            const char* newl = "\n";
            al_init(&commands, 16);
            //printf("%d\n", x);
            char* temp = al_lookup(&comms, x);
            if (temp == NULL) break;
            if(strchr(temp, '\n') != NULL){
                char* topush = strtok(temp, newl);
                temp = topush;
            }
            al_push(&commands, temp);
            x++;
            //printf("%s\n", temp);
            
            //if(x == al_length(&comms) - 1) break;  
            //printf("check\n");  
            while(al_lookup(&comms, x) != NULL && strchr(al_lookup(&comms, x), '\n') == NULL){
                al_push(&commands, al_lookup(&comms, x));
                x++;
                if(x == al_length(&comms)) break;
            }
              //printf("check\n");  
            /*
            else{
                printf("ind comm: ");
                char* tempstr = al_lookup(&comms, x);
                const char* newl = "\n";
                char* topush = strtok(tempstr, newl);
                printf("to push:%s\n", topush);
                al_push(&commands, topush);
                x++;
            }
            */
            al_push(&commands, NULL);
            write (STDOUT_FILENO, nl, strlen(nl));
        }
        else commands = parse(STDIN_FILENO);
        
        /*
        //temp code to made sure commands are reaching arraylist
        char* k = al_lookup(&commands, 0);
        //printf("%s", k);
        int u = 0;

        int c = size(&commands);
        //printf("%d\n", c);
        if (c == 0) return 1;
        //int z;
        while(k != NULL){
            write (STDOUT_FILENO, k, strlen(k));
            u++;
            k = al_lookup(&commands, u);
            //p = strtok()
            //printf("%d ", i);
            
            write (STDOUT_FILENO, nl, strlen(nl));
        }
        printf("\ndone\n");
        */
        if(al_lookup(&commands, 0) == NULL) break;
        if(!strcmp(al_lookup(&commands, 0), "exit")) break;
        //else continue;

        /*
        int j = size(&commands);
        if (j == 0) continue;
        //int z;
        for(int i = 0; i < j; i++){
            char* p = al_lookup(&commands, i);
            
            write (STDOUT_FILENO, p, strlen(p));
            write (STDOUT_FILENO, nl, strlen(nl));
        }
        if(!strcmp(al_lookup(&commands, 0), "exit")) break;
        else continue;
        */
        
        //do stuff//
       
        //Now we have to go through the commands and execute them
        //special cases we have to account for:
        //     "|"    -  Sub Command
        //  "<" & ">" -  File redirect
        //     "*"    -  Wildcards
        
        char *cmd;

        int z = 0;
        int l = al_length(&commands);
        char* command = al_lookup(&commands, 0);
        char* in = NULL;
        char* out = NULL;
        p = 0;
        int indicator = 0;
        int i = 0;

        
        //write (STDOUT_FILENO, mmsg, strlen(mmsg));
        //write (STDOUT_FILENO, command, strlen(command));
        //write (STDOUT_FILENO, nl, strlen(nl));

        list_t parameters;
        al_init(&parameters, 32);
        //char* parameters[l];
        char* cur;
        
        //write (STDOUT_FILENO, msg, strlen(msg));
        while((cur = al_lookup(&commands, i))){
            //printf("here\n");
            /*
            if(i == 0){
                if (strchr(command, '/')){
                    char buf[strlen(command) +1];
                    strcpy(buf, command);
                    const char s[2] = "/";
                    char *token;
                    //char *et;
                    token = strtok(buf, s);
                    while( token != NULL ) {
                        
                        token = strtok(NULL, s);
                    }
                    al_push(&parameters, token);
                    continue;
                }
            }
            */    
            if (!strcmp(cur, "<")){
                //printf("redirect input\n");
                if(in != NULL || indicator != 0){
                        write (STDOUT_FILENO, inerr, strlen(inerr));
                        err = 1;
                        break;
                    }
                indicator = 1;
                i++;
                continue;
            }
            if (!strcmp(cur, ">")){
                //printf("redirect output\n");
                if(out != NULL || indicator != 0){
                        write (STDOUT_FILENO, outerr, strlen(outerr));
                        err = 1;
                        break;
                    }
                indicator = -1;
                i++;
                continue;
            }

            //check for pipe
            if(!strcmp(cur, "|")){
                if(out != NULL || in != NULL || indicator != 0){
                    write (STDOUT_FILENO, tmerr, strlen(tmerr));
                    err = 1;
                }
                p = 1;
                i++;
                break;
            }

            //react to </>
            if (indicator != 0){
                //change input
                if(indicator == 1){
                    //detect illegal input
                    
                    in = cur;
                    indicator = 0;
                    i++;
                    continue;
                }
                //change output
                else if(indicator == -1){
                    //detect illegal input
                    
                    out = cur;
                    indicator = 0;
                    i++;
                    continue;
                }
            }

            //check for glob
            
                if(strchr(cur, '*')){
                    //printf("ast\n");
                    asterisk(cur, &parameters);
                    i++;
                    continue;
                }
            

            //push cur
            al_push(&parameters, cur);
            

            //check for exit
            if (!strcmp(cur, exit)) {
                z =1;
                break;
            }

            //check for pwd
           

            
            //write (STDOUT_FILENO, cur, strlen(cur));
            //write (STDOUT_FILENO, nl, strlen(nl));
            i++;
        }

        //address illegal input
        if (err == 1){
            err =0;
            write (STDOUT_FILENO, oop, strlen(oop));
            continue;
        }
        
        //temp code to confirm parameters  
        char** param = al_data(&parameters);
        int pl = al_length(&parameters);

        /*
        printf("confirm parameters\n");
        for(int w = 0; w < pl; w++){
            printf("%s\n", param[w]);
        }
        */

        //repeat for second command if fork
        if (p == 1){     
            char* c2 = al_lookup(&commands, i);
            list_t p2;
            al_init(&p2, 16);
            int iinit = i;

            //finish parsing input
            while((cur = al_lookup(&commands, i))){
                //printf("here\n");
                /*
                if(i == iinit){
                    if (strchr(command, '/')){
                        const char s[2] = "/";
                        char *token;
                        char *et;
                        token = strtok(command, s);
                    while( token != NULL ) {
                        printf( " %s\n", token );
                        et = token;
                        token = strtok(NULL, s);
                    }
                    al_push(&parameters, et);
                    continue;
                    }
                
                }
                */
                //detect input redirect
                if (!strcmp(cur, "<") || !strcmp(cur, ">")){
                    //printf("redirect input\n");
                    write (STDOUT_FILENO, tmerr, strlen(tmerr));
                    err = 1;
                    break;
                }

                //detect illegal input
                if(!strcmp(cur, "|")){
                    write (STDOUT_FILENO, piperr, strlen(piperr));;
                    err = 1;
                    break;
                }

                
                //check for glob
                if(strchr(cur, '*')){
                    asterisk(cur, &parameters);
                    i++;
                    continue;
                }
                

                //push to parameters 2 arraylist
                al_push(&p2, cur);

                //check if exit
                if (!strcmp(cur, exit)) {
                    z =1;
                    break;
                }


                //check if pwd
                

            
                //write (STDOUT_FILENO, cur, strlen(cur));
                //write (STDOUT_FILENO, nl, strlen(nl));
                i++;
            }

            //address illegal input
            if (err == 1){
                err =0;
                write (STDOUT_FILENO, oop, strlen(oop));
                continue;
            }
            //setup variables
            char *cmd2;
            param = al_data(&p2);
            int pl = al_length(&p2);

            /*
            //temp parameter confirmation
            printf("confirm 2 parameters\n");
            for(int i = 0; i < pl; i++){
                printf("%s\n", param[i]);
            }
            */

            //now pipe, we have both commands and parameters

            //pipe ends
            int fd[2];
            if(pipe(fd) == -1){
                write(STDOUT_FILENO, pipefail, strlen(pipefail));
            }
            //create process 1
            int pid1 = fork();
            if(pid1 < 0){
                write(STDOUT_FILENO, forkfail, strlen(forkfail));
            }

            //change out and execute process 1
            if (pid1 == 0){
                //child
                dup2(fd[1], STDOUT_FILENO);
                close(fd[0]);
                close(fd[1]);

                if (!strcmp(command, pwd)) {
                    getDir();
                    return 0;
                }

                if(strchr(command, '/') != NULL) strcpy(cmd, command);
                //get command pathif necessary
                else{
                    cmd = checkFile(command);
                    if (cmd == NULL) return 4;
                }
                if (execv (cmd, al_data(&parameters)) == -1){ //execute command
                    return 3;
                }
            }


            if (z ==1) break;
            if (z == 2) continue;


            //create process 2
            int pid2 = fork();
            if(pid2 < 0){
                write(STDOUT_FILENO, forkfail, strlen(forkfail));
            }

            //change input and execute process 2
            if(pid2 == 0){
                //child
                dup2(fd[0], STDIN_FILENO);
                close(fd[0]);
                close(fd[1]);

                if (!strcmp(command, pwd)) {
                    getDir();
                    return 0;
                }
                
                if(strchr(c2, '/') != NULL) strcpy(cmd2, c2);
                //get command path if necessary
                else{
                    cmd2 = checkFile(c2);
                    if (cmd2 == NULL) return 4;
                }
                if (execv (cmd2, al_data(&p2)) == -1){ //execute command
                    return 3;
                }
            }

            //parent
            close(fd[0]);
            close(fd[1]);

            int pid1stat;
            int pid2stat;
            waitpid(pid1, &pid1stat, 0);
            waitpid(pid2, &pid1stat, 0);

            int p2sc = 0;
            int p1sc = 0;

            if(WIFEXITED(pid1stat)){
                p1sc = WEXITSTATUS(pid1stat);
                if (p1sc == 1) write (STDOUT_FILENO, filefail, strlen(filefail));
                if (p1sc == 2) write (STDOUT_FILENO, dupfail, strlen(dupfail));
                if (p1sc == 3) write (STDOUT_FILENO, execfail, strlen(execfail));
                if (p1sc == 4) write (STDOUT_FILENO, comfail, strlen(comfail));

            }

            if(WIFEXITED(pid2stat)){
                p2sc = WEXITSTATUS(pid2stat);
                if (p2sc == 1) write (STDOUT_FILENO, filefail, strlen(filefail));
                if (p2sc == 2) write (STDOUT_FILENO, dupfail, strlen(dupfail));
                if (p2sc == 3) write (STDOUT_FILENO, execfail, strlen(execfail));
                if (p2sc == 4) write (STDOUT_FILENO, comfail, strlen(comfail));

            }

            if (p1sc != 0 || p2sc != 0) write (STDOUT_FILENO, oop, strlen(oop));

            //clean up
            al_destroy(&commands);
            al_destroy(&parameters);
            al_destroy(&p2);
            continue;
        }


        /*
        //temp code to check input/output redirect
        if (in != NULL) printf("final input will be: %s\n", in);
        else printf("no in\n");
        if (out != NULL) printf("final output will be: %s\n", out);
        else printf("no out\n");
        */
      
        if (z ==1) break;
        if (z == 2) continue;
        

        //push NULL end
        al_push(&parameters, NULL);




        //temp call to cd - need to change!!
        if(!strcmp(command, cd)) {
            changeDir(al_lookup(&parameters, 1));
            //printf("changed\n");
            al_destroy(&commands);
            al_destroy(&parameters);
            continue;
        }

        
        
        //create child process
        if(fork() != 0) {   //Parent
            int wstatus;    //Wait for child
            wait(&wstatus);
            if(WIFEXITED(wstatus)){
                int sc = WEXITSTATUS(wstatus);
                if (sc == 1) write (STDOUT_FILENO, filefail, strlen(filefail));
                if (sc == 2) write (STDOUT_FILENO, dupfail, strlen(dupfail));
                if (sc == 3) write (STDOUT_FILENO, execfail, strlen(execfail));
                if (sc == 4) write (STDOUT_FILENO, comfail, strlen(comfail));

                if (sc != 0) write (STDOUT_FILENO, oop, strlen(oop));
            }
        }
        else{
            
            //check if output redirect
            if(out != NULL){
                //int saved = dup(STDOUT_FILENO);
                int file = open(out, O_WRONLY|O_CREAT, 0640);
                if (file == -1){
                    return 1;
                }
                
                if (dup2(file, STDOUT_FILENO) == -1){
                    return 2;
                }
            }

            //check if input redirect
            if(in != NULL){
                //int saved = dup(STDOUT_FILENO);
                int file = open(in, O_RDONLY);
                if (file == -1){
                    return 1;
                }
                
                if (dup2(file, STDIN_FILENO) == -1){
                    return 2;
                }
            }
            if (!strcmp(command, pwd)) {
                getDir();
                return 0;
            }

            //get command path
            if(strchr(command, '/')) {
                char buff[1028];
                //printf("pathin\n");
                strcpy(buff, command);
                strncpy(cmd, buff, strlen(buff));
                //printf("command path: %s\n", cmd);
            }
            
            else{
            cmd = checkFile(command);
                if(cmd == NULL) {
                    return 4;
                }
            }
            //execute command
            if (execv (cmd, al_data(&parameters)) == -1){ //execute command

                return 3;
            } 
        }
        
        //printf("done\n");

        //clean arraylists
        al_destroy(&commands);
        al_destroy(&parameters);
    }

    if(err != 0) printf("!");
    else write (STDOUT_FILENO, omsg, strlen(omsg));
    //return EXIT_SUCCESS;

}

/*
void read_input(){
    int n;
    char buf[1024];
    int buflength = 128;
    while((n = read(STDIN_FILENO, buf, )) > 0)
}
*/


char* checkFile(char* command){
    struct stat sfile;
    static char ret[1024];
    //printf("checkfile!\n");
    char one[128];
    char two[128];
    char three[128];
    char four[128];
    char five[128];
    char six[128];

    strcpy(one, "/usr/local/sbin/");
    strcat(one, command);

    strcpy(two, "/usr/local/bin/");
    strcat(two, command);

    strcpy(three, "/usr/sbin/");
    strcat(three, command);

    strcpy(four, "/usr/bin/");
    strcat(four, command);

    strcpy(five, "/sbin/");
    strcat(five, command);

    strcpy(six, "/bin/");
    strcat(six, command);

    if(stat(one, &sfile) == 0){
        //printf("checkfile!1\n");
        strcpy(ret, "/usr/local/sbin/");
        strcat(ret, command);
        return ret;
    }

    else if(stat(two, &sfile) == 0){
        //printf("checkfile!2\n");
        strcpy(ret, "/usr/local/bin/");
        strcat(ret, command);
        return ret;
    }

    else if(stat(three, &sfile) == 0){
        //printf("checkfile!3\n");
        strcpy(ret, "/usr/sbin/");
        strcat(ret, command);
        return ret;
    }
    

    else if(stat(four, &sfile) == 0){
        //printf("checkfile!4\n");
        strcpy(ret, "/usr/bin/");
        strcat(ret, command);
        return ret;
    }

    else if(stat(five, &sfile) == 0){
        //printf("checkfile!5\n");
        strcpy(ret, "/sbin/");
        strcat(ret, command);
        return ret;
    }

    else if(stat(six, &sfile) == 0){
        //printf("checkfile!6\n");
        strcpy(ret, "/bin/");
        strcat(ret, command);
        return ret;
    }
    
    else {
        //printf("return null!\n");
        return NULL;
    }
}


void asterisk(char* tok, list_t* param){
    const char *ast = "*";
    
    if(strcmp(tok, "*")){
        //printf("in\n");
        struct dirent *de;  // Pointer for directory entry
        list_t parts;
        char* p[2];
        al_init(&parts, 8);

        char* nt = strtok(tok, ast);
        p[0] = nt;
        if(tok[0] == '*'){
            p[1] = p[0];
            p[0] = NULL;
        }
        else{
            char* nt = strtok(NULL, ast);
            p[1] = nt;
        }

        //printf("in: %s\n", p[0]);
        //printf("out: %s\n", p[1]);

        al_push(&parts, NULL);
        //printf("parts in \n");
        // opendir() returns a pointer of DIR type. 
        DIR *dr = opendir(".");
  
        if (dr == NULL){  // opendir returns NULL if couldn't open directory
            //printf("Could not open current directory" );
            //return 0;
        }
  
        while ((de = readdir(dr)) != NULL){
            //printf("%s\n", de->d_name);
            
            int chf = 1;
            int chb = 1;
            
            if(p[0] != NULL){
                for(int i = 0; i < strlen(p[0]); i++){
                    //printf("front - og: %c, file: %c\n", p[0][i], de->d_name[i]);
                    if (p[0][i] != de->d_name[i]) chf = 0;
                    printf("match? %d\n", chf);
                }
            }

            if(p[1] != NULL){
                for(int i = 0; i < strlen(p[1]); i++){
                    //printf("back - og: %c, file: %c\n",p[1][strlen(p[1]) -1 -i], de->d_name[strlen(de->d_name) -1 - i]);
                    if(p[1][strlen(p[1]) -1 -i] != de->d_name[strlen(de->d_name) -1 - i]) chb = 0;
                    //printf("match? %d\n", chf);
                }
            }

            if(chf == 1 && chb == 1) al_push(param, de->d_name);


            /*
            int i = 0;
            char* temp = al_lookup(&parts, i);
            while(temp != NULL){
                if(strstr(de->d_name, temp)){
                    i++;
                    temp = al_lookup(&parts, i);
                }
                else break;
            }
            if(temp == NULL) {
                al_push(param, de->d_name);
                printf("pushed: %s\n", de->d_name);
            }
            */
        }       
  
        closedir(dr);  
    }

    else{
        struct dirent *de;  // Pointer for directory entry
  
        // opendir() returns a pointer of DIR type. 
        DIR *dr = opendir(".");
  
        if (dr == NULL){  // opendir returns NULL if couldn't open directory
            printf("Could not open current directory" );
            //return 0;
        }
  
        while ((de = readdir(dr)) != NULL)
            printf("%s\n", de->d_name);
  
        closedir(dr);
    }
    /*
    DIR *d;
    struct dirent *dir;
    if(!strcmp(tok, "*")){
        printf("cmp\n");
        d = opendir(".");
        if(d){
            while(dir != NULL){
                if (dir->d_type == DT_REG){
                    printf("%s\n", dir->d_name);
                    al_push(param, dir->d_name);
                }
                dir = readdir(d);
            }
            closedir(d);
        }
    }
    return;
    
    char prior[strlen(tok)];
    char sub[strlen(tok)];
    int i = 0;
    int j = 0;
    while(tok[i] != '*'){
        prior[j] = tok[i];

    }
    
    */
}


//take input and compose into arrayList
list_t parse(int fd){

    list_t commands;
    al_init(&commands, 16);
    char* tok;
    tok_init(fd);
    
    //call tokenizer and fill arraylist
    while((tok = next_tok())){
        al_push(&commands, strdup(tok));
        free(tok);
    }
    al_push(&commands, NULL);
    
    return commands;
}

list_t parseb(int fd){

    list_t commands;
    al_init(&commands, 16);
    char* tok;
    tok_init(fd);
    
    //call tokenizer and fill arraylist
    while((tok = next_tokb())){
        al_push(&commands, strdup(tok));
        //printf("%s", tok);
        free(tok);
    }
    //printf("doneb");
    al_push(&commands, NULL);
    
    return commands;
}#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "arraylist.h"

#ifndef DEBUG
#define DEBUG 0
#endif

#ifdef SAFE
#define SAFETY_CHECK \
if (list->data == NULL) { \
	fputs("Use of unallocated or destroyed arraylist\n", stderr); \
	exit(EXIT_FAILURE); \
}
#else 
#define SAFETY_CHECK
#endif

/* Initialize an empty array list with the specified capacity.
 *
 * Returns 1 on success, or 0 if unable to allocate storage
 *
 * capacity must be greater than 0
 */
int al_init(list_t *list, unsigned capacity)
{
	if (DEBUG > 1) fprintf(stderr, "Initializing %p with %u\n", list, capacity);
	assert(capacity > 0);
	list->capacity = capacity;
	list->size = 0;
	list->data = malloc(sizeof(char*) * capacity);
	
	return list->data != NULL;
}

void al_destroy(list_t *list)
{
	if (DEBUG > 1) fprintf(stderr, "Destroying %p\n", list);
	SAFETY_CHECK

	free(list->data);

#ifdef SAFE
	list->data = NULL;
#endif
}

unsigned al_length(list_t *list)
{
	return list->size;
}

char** al_data(list_t *list){
	return list->data;
}

/* Writes the integer stored at the specified index to the specified destination
 *
 * Returns 1 on success, or 0 if the index is out of range
 */
char* al_lookup(list_t *list, unsigned index)
{
	SAFETY_CHECK

	if (index >= list->size) return 0;
	
	//dest = list->data[index];
	//printf("succ\n");
	return list->data[index];
}

/* Writes the given integer to the specified index in the list
 *
 * Returns 1 on success, or 0 if the index is out of range.
 * Does not extend the length of the list.
 */

int al_insert(list_t *list, unsigned index, char* src)
{

	SAFETY_CHECK
	
	if (index >= list->size) {
		printf("fail\n");
		return 0;
	}
	printf("done\n");
	list->data[index] = src;
	printf("%s\n", src);
	printf("%s\n", list->data[index]);
	return 1;
}

/* Appends integer to the end of the list
 *
 * Returns 1 on success, or 0 if memory allocation failed.
 */
int al_push(list_t *list, char* src)
{
	if (DEBUG > 1) fprintf(stderr, "push %p: %s\n", list, src);
	SAFETY_CHECK

	if (list->size == list->capacity) {
		int newcap = list->capacity * 2;
		char **new = realloc(list->data, sizeof(char*) * newcap);
		if (DEBUG) fprintf(stderr, "increase capacity of %p to %d\n", list, newcap);
		if (!new) return 0;

		// NOTE no changes are made to the list until we know allocation succeded
		list->data = new;
		list->capacity = newcap;
	}
	
	list->data[list->size] = src;
	//printf("%s\n", src);
	//printf("%s\n", list->data[list->size]);
	++list->size;
	
	return 1;
}


/* Copies last entry in list to destination and reduces size of list by 1.
 *
 * Returns 1 on success, or 0 if the list is empty.
 */
char* al_pop(list_t *list)
{
	if (DEBUG > 1) fprintf(stderr, "pop %p\n", list);
	SAFETY_CHECK
	
	if (list->size == 0) return 0;
	--list->size;
	//printf("%s\n", list->data[list->size]);
	//dest = list->data[list->size];
	
	
	
	return list->data[list->size];
}

int size(list_t *list){
	return list->size;
}
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include "tok.h"
 
#ifndef BUFSIZE
#define BUFSIZE 128
#endif
static char buf[BUFSIZE];
static unsigned pos;
static unsigned bytes;
static int closed;
static int input;
int esc = 0;
int end =0;

void tok_init(int fd){

    input = fd;
    pos = 0;
    bytes = 0;
    closed = 0;
}

char *next_tok(void){


    if (closed) return NULL;
    // skip whitespace
    
    while (1) {
    // ensure we have a char to read
    if (pos == bytes) {
            //printf("read\n");
            bytes = read(STDIN_FILENO, buf, BUFSIZE);
            //printf("red\n");
            if (bytes < 1) {
                closed = 1;
                return NULL;
            }
            pos = 0;
        }
        //if new line return null (end of line)
        if (buf[pos] == '\n') return NULL;
        if (!isspace(buf[pos])) break;
        ++pos;
    }

    // start reading text
    int start = pos;
    char *tok = NULL;
    int toklen = 0;
    
    do {
        //printf("readcom\n");

        //check exceptions
        if (buf[pos] == '<' || buf[pos] == '>' || buf[pos] == '|'){

            if(pos > start){
                break;
            }
            else if(pos==start){
                pos++;
                break;
            }
            
        }

        //increment forward
        ++pos;

        //check for end of line
        if(buf[pos] == '\n') {
            if(pos > start){
                break;
            }
        }

        //if reached end of buffer
        if (pos == bytes) {
            //printf("ref\n");
            // refresh the buffer (see if at end)
            bytes = read(STDIN_FILENO, buf, BUFSIZE);
            if (bytes < 1) {
                closed = 1;
                break;
            }

            // save word so far
            int fraglen = pos - start;
            tok = realloc(tok, toklen + fraglen + 1);
            memcpy(tok + toklen, buf + start, fraglen);
            toklen += fraglen;

            pos = 0;
            start = 0;
        }

    } while (!isspace(buf[pos]));

    // grab the word from the current buffer
    // (Note: start == pos if we refreshed the buffer and got a space first.)
    if (start < pos) {
        int fraglen = pos - start;
        tok = realloc(tok, toklen + fraglen + 1);
        memcpy(tok + toklen, buf + start, fraglen);
        toklen += fraglen;
    }

    //append string end
    if (tok) {
        tok[toklen] = '\0';
    }
    return tok;
}

char *next_tokb(void){
    //printf("nt\n");
    if(end == 1) return NULL;
    if (closed) return NULL;
    // skip whitespace
    
    while (1) {
    // ensure we have a char to read
    if (pos == bytes) {
            //printf("read\n");
            bytes = read(STDIN_FILENO, buf, BUFSIZE);
            //printf("red\n");
            if (bytes < 1) {
                closed = 1;
                return NULL;
            }
            pos = 0;
        }
        //if new line return null (end of line)
        if (buf[pos] == '\n') break;
        if (!isspace(buf[pos])) break;
        ++pos;
    }

    // start reading text
    int start = pos;
    char *tok = NULL;
    int toklen = 0;
    
    do {
        //printf("readcom\n");

        //check exceptions
        if (buf[pos] == '<' || buf[pos] == '>' || buf[pos] == '|'){

            if(pos > start){
                break;
            }
            else if(pos==start){
                pos++;
                break;
            }
            
        }

        //increment forward
        ++pos;

        //check for end of line
        if(buf[pos] == '\n') {
            if(pos > start){
                break;
            }
        }

        //if reached end of buffer
        if (pos == bytes) {
            //printf("ref\n");
            // refresh the buffer (see if at end)
            bytes = read(STDIN_FILENO, buf, BUFSIZE);
            if (bytes < 1) {
                closed = 1;
                break;
            }

            // save word so far
            int fraglen = pos - start;
            tok = realloc(tok, toklen + fraglen + 1);
            memcpy(tok + toklen, buf + start, fraglen);
            toklen += fraglen;

            pos = 0;
            start = 0;
        }

    } while (!isspace(buf[pos]));

    // grab the word from the current buffer
    // (Note: start == pos if we refreshed the buffer and got a space first.)
    if (start < pos) {
        int fraglen = pos - start;
        tok = realloc(tok, toklen + fraglen + 1);
        memcpy(tok + toklen, buf + start, fraglen);
        toklen += fraglen;
    }

    //append string end
    if (tok) {
        tok[toklen] = '\0';
    }

    //printf("%s\n", tok);
    char* cmp = "exit";

    if(!strcmp(tok, cmp)) end = 1;

    return tok;
}#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "arraylist.h"
#include "tok.h"

int main(){
    //arraylist tests
    list_t commands;
    al_init(&commands, 8);

    char* str = "hello";
    char* str2 = "helloo";
    char* str3 = "hellooo";
    char* res;

    char* one = "one";

    

    al_push(&commands, str);
    al_push(&commands, str2);
    al_push(&commands, str3);
    res = al_lookup(&commands, 0);
    printf("%s\n", res);
    al_insert(&commands, 0, one);
    res = al_lookup(&commands, 0);
    printf("%s\n", res);
    res = al_pop(&commands);
    res = al_pop(&commands);
    //if(al_pop(res, &commands)){
        printf("%s\n", res);
    //}
    //else printf("fail\n");

    return EXIT_SUCCESS;
}#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "arraylist.h"
#include "tok.h"

/*
    dealing with bad syntax, e.g., foo < < bar 
    -> print an error message and skip to the next \name

    dealing with nonsense, e.g., foo > bar | baz
        where should the output for foo go?
            (most shell will sent it to bar and send nothing to baz)

consider edge cases and weird scenarios
    we discussed combining redirection and pipes

    program1 < input | program2 > output
        fine!

    program1 < input > output1 | program2
        problem! does output of program1 go to output1 or the pipe?
        should we just not allow this and report an error?

    program1 | program2 < input

    where are wildcards allowed?

    can you use a wildcard in the first word?
        ./m*sh
        yes!

    can you use a wildcard in a redirection?

echo test > foo*
yes, but only if the pattern matches exactly one file!
(you don't need to handle this in the assignment)

*/

int main (int argc, char **argv){

    //does the shell continue 

    return;
}#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "arraylist.h"
#include "tok.h"

//parse through input, split into tokens, and put into arraylist
list_t parse(int fd){
    list_t commands;
    al_init(&commands, 8);

    char* tok;

    tok_init(fd);

    while((tok = next_tok())){
        al_push(&commands, strdup(tok));
        free(tok);
    }
    
    return commands;
}

int main(int argc, char *argv[]) { 
    list_t arr = parse(STDIN_FILENO);
    int j = size(&arr);
    for(int i = 0; i < j; i++){
        char* p = al_lookup(&arr, i);
        printf("%s\n", p);
    }
    return EXIT_SUCCESS;
}